#+TITLE: init.el
#+PROPERTY: header-args :tangle yes :results silent

My emacs config is a package so that straight precompiles it.

#+BEGIN_SRC emacs-lisp
  ;;; ml-init.el --- My config as a package  -*- lexical-binding: t; -*-

  ;;; Commentary:

  ;;; Code:

#+END_SRC

* Globals
#+BEGIN_SRC emacs-lisp
  ;; In some X/WM configurations (e.g. xpra with i3) emacs only fills its assigned frame to
  ;; a multiple of the character width/height, leaving an ugly black border. This ensures
  ;; that all frames always fill their space pixel perfect.
  (setq frame-resize-pixelwise t)

  (setf ring-bell-function 'ignore)

  (setq-default cursor-type 'bar)

  ;; Configure the *scratch* buffer
  (setf initial-scratch-message ""
        initial-major-mode 'emacs-lisp-mode)

  ;; Enable X clipboards
  (setf x-select-enable-clipboard t
        x-select-enable-primary t)

  ;; Put more information into the frame title
  (setf frame-title-format '("" invocation-name ": %b - " mode-name))

  ;; Enable all commands
  (mapatoms (lambda (s) (when (get s 'disabled) (put s 'disabled nil))))

  ;; Show column numbers
  (column-number-mode t)

  ;; y and n instead of yes and no
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; Create new files and buffers without confirmation
  (setq confirm-nonexistent-file-or-buffer nil)
  (setq ido-create-new-buffer 'always)

  ;; Read 1M at a time from processes. Important for LSP performance.
  (setq read-process-output-max (* 1024 1024))

  ;; Indent with 2 spaces
  (setq-default indent-tabs-mode nil
                tab-width 2
                js-indent-level 2
                css-indent-offset 2
                sh-indentation 2
                web-mode-markup-indent-offset 2
                web-mode-code-indent-offset 2
                web-mode-css-indent-offset 2
                web-mode-attr-indent-offset 2)

  ;; Store a few MB of undo history in each buffer. For example, isortify and blacken erase
  ;; and recreate the whole buffer which can make the undo history grow pretty quickly.
  (setq undo-limit (* 2 1024 1024)
        undo-strong-limit (* 10 1024 1024)
        undo-outer-limit (* 10 1024 1024))

  ;; Line breaks at 90 characters
  (setq-default fill-column 90)

  ;; I don't like the GNU style of two spaces after a period
  (setq-default sentence-end-double-space nil)

  ;; Append a newline at the end of files
  (setq require-final-newline t)

  ;; Disable backups and autosaves
  (setq backup-inhibited t)
  (setq auto-save-default nil)

  ;; Yank at point instead of position of cursor
  (setf mouse-yank-at-point t)

  ;; Never re-center during scrolling and keep some distance between point and the window
  ;; margin
  (setq scroll-conservatively 101
        scroll-margin 3)

  ;; I do not like accidentally freezing my emacs instance
  (global-set-key (kbd "C-z") nil)

  ;; Disable GC while the minibuffer is active (taken from doom)
  (defun ml-defer-garbage-collection-h ()
    (setq gc-cons-threshold most-positive-fixnum))

  (defun ml-restore-garbage-collection-h ()
    ;; Defer it so that commands launched immediately after will enjoy the
    ;; benefits.
    (run-at-time 1 nil #'ml-restore-gc-threshold))

  (add-hook 'minibuffer-setup-hook #'ml-defer-garbage-collection-h)
  (add-hook 'minibuffer-exit-hook #'ml-restore-garbage-collection-h)
#+END_SRC

Automatically jump to origin file and line when an the point is on an error.

#+BEGIN_SRC emacs-lisp
  (add-hook 'compilation-mode-hook #'next-error-follow-minor-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; Start a server for emacsclient
  ;; (require 'server)
  ;; (unless (server-running-p)
  ;;   (server-start))
#+END_SRC

* Packages

Packages are configured with the ~use-package~ macro.

#+BEGIN_SRC emacs-lisp
  (require 'bind-key)
  (use-package use-package-chords
    :config (key-chord-mode t)
    :straight t)

  (use-package hydra :straight t)

  (use-package pretty-hydra :straight t)
#+END_SRC

* Tramp

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :init
    (setq tramp-default-method "ssh"
          tramp-terminal-type "tramp"
          tramp-connection-timeout 10
          tramp-ssh-controlmaster-options
          "-o ControlMaster=auto -o ControlPath='~/.ssh/tramp.%%C' -o ControlPersist=5m"))
#+END_SRC

* Utilities

The ~cqql~ package (conspicuously named after myself) contains a loose collection of
utility functions and commands which is why it cannot be put easily into one of the
existing sections.

#+BEGIN_SRC emacs-lisp
  (use-package cqql
    :straight (cqql :local-repo "mlextras" :type nil)
    :bind (("C-a" . cqql-go-to-beginning-of-line-dwim)
           ("M-D" . cqql-duplicate-text)
           ("C-S-k" . cqql-kill-line)
           ("C-o" . cqql-open-line)
           ("C-S-o" . cqql-open-line-above)
           ("C-S-p" . cqql-move-text-up)
           ("C-S-n" . cqql-move-text-down))
    :custom ((cqql-no-trimming-modes (list #'snippet-mode)))
    :config
    (add-hook 'before-save-hook #'cqql-trim-whitespace))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package write-only
    :straight (write-only :local-repo "mlextras" :type nil)
    :bind (("S-<f7>" . write-only-mode)))
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (use-package tmp-buffer
    :straight (tmp-buffer :local-repo "mlextras" :type nil)
    :bind ("C-c n" . tmp-buffer))

  (use-package window-extras
    :straight (window-extras :local-repo "mlextras" :type nil)
    :bind (("C-c w t" . transpose-windows)
           ("C-c w v" . toggle-window-split)))
#+END_SRC

** PATH

Teach emacs my modified ~PATH~ so that it can, for example, find local python
installations. We have to set ~exec-path-from-shell-arguments~ to ~""~ so that
it uses an interactive shell instead of a login one which would not read my
~.zshenv~ file, where ~PATH~ is initialized.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :straight t
    :custom (exec-path-from-shell-arguments "")
    :config (exec-path-from-shell-initialize))
#+END_SRC

* UI

** Theme

#+BEGIN_SRC emacs-lisp
  (use-package nord-theme
    :straight t
    :config (load-theme 'nord t))

  (use-package zerodark-theme
    :straight t
    :after flycheck
    :config (zerodark-setup-modeline-format))
#+END_SRC

** Mode Line

#+BEGIN_SRC emacs-lisp
  (use-package rich-minority
    :straight t
    :config
    ;; Hide all minor modes
    (setq rm-whitelist (list "")))

  (use-package smart-mode-line
    :straight t
    :config
    (setf sml/theme 'respectful
          sml/no-confirm-load-theme t)

    (sml/setup))
#+END_SRC

** Minibuffer

Save the minibuffer history.

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :straight t
    :config
    (setf history-length 200)
    (savehist-mode))
#+END_SRC

** eldoc

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :config (setf eldoc-idle-delay 0.2))
#+END_SRC

** Better Help

Displays all key bindings of the current major mode with one-line descriptions
in a condensed format.

#+BEGIN_SRC emacs-lisp
  (use-package discover-my-major
    :straight t
    :bind ("C-h C-m" . discover-my-major))
#+END_SRC

~helpful~ puts a lot of extra funcionality on help pages such as the source code
of functions.

#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :straight t
    :bind (("C-h a" . helpful-command)
           ("C-h f" . helpful-callable)
           ("C-h v" . helpful-variable)
           ("C-h k" . helpful-key)
           :map emacs-lisp-mode-map
           ("C-c C-d" . helpful-at-point)))
#+END_SRC

** Buffer Switching

#+BEGIN_SRC emacs-lisp
  (defun iflipb-kill-this-buffer ()
    "Same as `kill-buffer' but keep the iflipb buffer list state."
    (interactive)
    (kill-buffer (current-buffer))
    (if (iflipb-first-iflipb-buffer-switch-command)
        (setq last-command 'kill-buffer)
      (if (< iflipb-current-buffer-index (length (iflipb-interesting-buffers)))
          (iflipb-select-buffer iflipb-current-buffer-index)
        (iflipb-select-buffer (1- iflipb-current-buffer-index)))
      (setq last-command 'iflipb-kill-buffer)))

  (defun ml-iflipb-ignore-special-except-some (bufname)
    "Check if BUFNAME is a special buffer except for some special cases."
    (or (and (string-prefix-p "*" bufname)
             (not (string-prefix-p "*Org Src" bufname))
             (not (string-prefix-p "*deadgrep" bufname)))
        (string-match-p "^magit\\(-[^:]+\\)?:" bufname)))

  (use-package iflipb
    :straight t
    :demand t
    :bind (("<f6>" . iflipb-next-buffer)
           ("S-<f6>" . iflipb-previous-buffer)
           ("M-<f6>" . iflipb-kill-this-buffer))
    :custom ((iflipb-ignore-buffers #'ml-iflipb-ignore-special-except-some)
             (iflipb-current-buffer-template "[%.15s]")
             (iflipb-other-buffer-template "%.15s")))
#+END_SRC

** Searching & Selection

The ~selectrum~ ecosystem offers a rich combination of libraries and tools that integrate
with emacs built-in APIs.

#+BEGIN_SRC emacs-lisp
  (use-package selectrum
    :straight t
    :config (selectrum-mode))

  (use-package prescient
    :straight t
    :custom ((prescient-filter-method '(fuzzy initialism literal regexp)))
    :config (prescient-persist-mode))

  (use-package selectrum-prescient
    :straight t
    :after (selectrum prescient)
    :config (selectrum-prescient-mode))

  (use-package marginalia
    :straight t
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :config (marginalia-mode))

  (use-package consult
    :straight t
    :after hydra
    :custom
    (consult-project-root-function #'projectile-project-root)
    (consult-narrow-key "<")
    (register-preview-delay 0)
    (register-preview-function #'consult-register-format)
    ;; Use consult to select xref locations with preview
    (xref-show-definitions-function #'consult-xref)
    :bind (("C-s" . consult-line)
           ("C-S-s" . isearch-forward)
           ("C-c s" . consult-ripgrep)
           ("C-x f" . find-file)
           ("C-c M-o" . selectrum-repeat)
           ("M-y" . consult-yank-pop)
           ("C-x b" . consult-buffer)
           ("C-x 4 b" . consult-buffer-other-window)
           ("C-x 5 b" . consult-buffer-other-frame)
           ("C-x M-:" . consult-complex-command)
           ("C-c c" . hydra-consult/body)

           ;; Isearch integration
           :map isearch-mode-map
           ("M-s l" . consult-line))

    :init
    (defhydra hydra-consult (:exit t :hint nil)
        "
     Line^^       Region^^           Goto^^             Other
    ----------------------------------------------------------
     [_f_] find   [_k_] focus lines  [_m_] mark         [_a_] apropos
     [_l_] locate [_K_] keep lines   [_M_] global mark  [_c_] mode command
     [_e_] error                   [_o_] outline      [_b_] bookmark"
        ("f" consult-find)
        ("l" consult-locate)
        ("K" consult-keep-lines)
        ("k" consult-focus-lines)
        ("e" consult-compile-error)
        ("m" consult-mark)
        ("M" consult-global-mark)
        ("o" consult-outline)
        ("a" consult-apropos)
        ("c" consult-mode-command)
        ("b" consult-bookmark)
        ("<F3>" consult-kmacro))

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window))

  (use-package which-key :straight t)

  (use-package embark
    :straight t
    :bind ("M-o" . embark-act)
    :config
    (require 'which-key)
    (setq embark-action-indicator
          (lambda (map _target)
            (which-key--show-keymap "Embark" map nil nil 'no-paging)
            #'which-key--hide-popup-ignore-command)
          embark-become-indicator embark-action-indicator))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :straight t
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook (embark-collect-mode . embark-consult-preview-minor-mode))
#+END_SRC

** File search with rg

#+BEGIN_SRC emacs-lisp
  (use-package deadgrep
    :straight t
    :bind (("<f9>" . deadgrep)))

  (use-package cqql-deadgrep
    :straight (cqql-deadgrep :local-repo "mlextras" :type nil)
    :after deadgrep
    :bind (("S-<f9>" . cqql-deadgrep-here)
           :map deadgrep-mode-map
           ("s" . cqql-deadgrep-search-term)
           ("d" . cqql-deadgrep-directory)
           ("a" . cqql-deadgrep-file-type-all)
           ("t" . cqql-deadgrep-file-type-type)
           ("S-g" . cqql-deadgrep-file-type-glob)))
#+END_SRC

** Highlighting

*** Cursor

#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :straight t
    :config
    (beacon-mode))
#+END_SRC

*** Delimiter

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :straight t
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)

    (setf rainbow-delimiters-max-face-count 6))
#+END_SRC

*** Symbols

#+BEGIN_SRC emacs-lisp
  (use-package highlight-symbol
    :straight t
    :config
    (add-hook 'prog-mode-hook 'highlight-symbol-mode)

    (setf highlight-symbol-idle-delay 0))
#+END_SRC

** Window Management

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :straight t
    :bind ("M-i" . ace-window))
#+END_SRC

** Buffer Management

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind ("C-x C-b" . ibuffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :config (setf uniquify-buffer-name-style 'forward
                  uniquify-strip-common-suffix t))
#+END_SRC

** File Management

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :config
    (setf dired-listing-switches "-lahv")

    (bind-key "M-w" #'wdired-change-to-wdired-mode dired-mode-map))
#+END_SRC

~dired-jump~ from ~dired-x~ is probably my most used ~dired~ command.

#+BEGIN_SRC emacs-lisp
  (use-package dired-x)
#+END_SRC

** Project Management

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :straight t
    :bind (("C-x C-f" . projectile-find-file))
    :init
    (setq projectile-keymap-prefix (kbd "C-x p"))
    :config
    (projectile-global-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun ml-treemacs-dwim ()
    "Toggle treemacs."
    (interactive)
    (if (and (eq (treemacs-current-visibility) 'visible)
             treemacs--in-this-buffer)
        (delete-window (treemacs-get-local-window))
      (call-interactively #'treemacs-select-window)))

  (use-package treemacs
    :straight t
    :commands (treemacs-current-visibility)
    :bind (("<f8>" . ml-treemacs-dwim)
           ("S-<f8>" . treemacs)
           ("<mouse-1>" . treemacs-single-click-expand-action))
    :config
    ;; Hide gitignored files via the toggle call instead of customizing the variable because
    ;; we need the interactive behavior that happens in the toggle call to actually hide the
    ;; files.
    (treemacs-hide-gitignored-files-mode t))

  (use-package treemacs-projectile
    :straight t
    :after (treemacs projectile))
#+END_SRC

* Editing

** Better Defaults

The dwim commands should just be the default in modern emacs.
#+BEGIN_SRC emacs-lisp
  (bind-keys ("M-u" . upcase-dwim)
             ("M-l" . downcase-dwim)
             ("M-c" . capitalize-dwim))
#+END_SRC

** Multiple Cursors

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :straight t
    :after hydra
    :bind (("C-c m" . hydra-multiple-cursors/body)
           :map mc/keymap
           ;; Make enter insert a newline instead of quitting mc
           ("<return>" . nil))
    :config
    (defhydra hydra-multiple-cursors (:hint nil)
      "
   Up^^             Down^^           Miscellaneous           % 2(mc/num-cursors) cursor%s(if (> (mc/num-cursors) 1) \"s\" \"\")
  ------------------------------------------------------------------
   [_p_]   Next     [_n_]   Next     [_l_] Edit lines  [_0_] Insert numbers
   [_P_]   Skip     [_N_]   Skip     [_a_] Mark all    [_A_] Insert letters
   [_M-p_] Unmark   [_M-n_] Unmark   [_s_] Search
   [Click] Cursor at point       [_q_] Quit"
      ("l" mc/edit-lines :exit t)
      ("a" mc/mark-all-like-this :exit t)
      ("n" mc/mark-next-like-this)
      ("N" mc/skip-to-next-like-this)
      ("M-n" mc/unmark-next-like-this)
      ("p" mc/mark-previous-like-this)
      ("P" mc/skip-to-previous-like-this)
      ("M-p" mc/unmark-previous-like-this)
      ("s" mc/mark-all-in-region-regexp :exit t)
      ("0" mc/insert-numbers :exit t)
      ("A" mc/insert-letters :exit t)
      ("<mouse-1>" mc/add-cursor-on-click)
      ;; Help with click recognition in this hydra
      ("<down-mouse-1>" ignore)
      ("<drag-mouse-1>" ignore)
      ("q" nil)))
#+END_SRC

** SmartParens

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :straight t
    :init
    (require 'hydra)
    (defhydra hydra-smartparens (:hint nil)
      "
   Moving^^^^                       Slurp & Barf^^   Wrapping^^            Sexp juggling^^^^               Destructive
  ------------------------------------------------------------------------------------------------------------------------
   [_a_] beginning  [_n_] down      [_h_] bw slurp   [_R_]   rewrap        [_S_] split   [_t_] transpose   [_c_] change inner  [_w_] copy
   [_e_] end        [_N_] bw down   [_H_] bw barf    [_u_]   unwrap        [_s_] splice  [_A_] absorb      [_C_] change outer
   [_f_] forward    [_p_] up        [_l_] slurp      [_U_]   bw unwrap     [_r_] raise   [_E_] emit        [_k_] kill          [_g_] quit
   [_b_] backward   [_P_] bw up     [_L_] barf       [_(__{__[_] wrap (){}[]   [_j_] join    [_o_] convolute   [_K_] bw kill       [_q_] quit"
      ;; Moving
      ("a" sp-beginning-of-sexp)
      ("e" sp-end-of-sexp)
      ("f" sp-forward-sexp)
      ("b" sp-backward-sexp)
      ("n" sp-down-sexp)
      ("N" sp-backward-down-sexp)
      ("p" sp-up-sexp)
      ("P" sp-backward-up-sexp)

      ;; Slurping & barfing
      ("h" sp-backward-slurp-sexp)
      ("H" sp-backward-barf-sexp)
      ("l" sp-forward-slurp-sexp)
      ("L" sp-forward-barf-sexp)

      ;; Wrapping
      ("R" sp-rewrap-sexp)
      ("u" sp-unwrap-sexp)
      ("U" sp-backward-unwrap-sexp)
      ("(" sp-wrap-round)
      ("{" sp-wrap-curly)
      ("[" sp-wrap-square)

      ;; Sexp juggling
      ("S" sp-split-sexp)
      ("s" sp-splice-sexp)
      ("r" sp-raise-sexp)
      ("j" sp-join-sexp)
      ("t" sp-transpose-sexp)
      ("A" sp-absorb-sexp)
      ("E" sp-emit-sexp)
      ("o" sp-convolute-sexp)

      ;; Destructive editing
      ("c" sp-change-inner :exit t)
      ("C" sp-change-enclosing :exit t)
      ("k" sp-kill-sexp)
      ("K" sp-backward-kill-sexp)
      ("w" sp-copy-sexp)

      ("q" nil)
      ("g" nil))
    :config
    (require 'smartparens-config)

    (bind-keys :map smartparens-mode-map
      ("C-M-f" . sp-forward-sexp)
      ("C-M-b" . sp-backward-sexp)
      ("C-M-n" . sp-down-sexp)
      ("C-M-S-n" . sp-backward-down-sexp)
      ("C-M-p" . sp-up-sexp)
      ("C-M-S-p" . sp-backward-up-sexp)
      ("C-M-a" . sp-beginning-of-sexp)
      ("C-M-e" . sp-end-of-sexp)
      ("C-M-k" . sp-kill-sexp)
      ("C-M-t" . sp-transpose-sexp))

    (smartparens-global-mode t)
    (smartparens-strict-mode t)
    (show-smartparens-global-mode t)

    ;; We write it the verbose way instead of with sp-with-modes because
    ;; use-package does not properly expand the macro somehow during compilation
    (sp-local-pair sp--html-modes "{{" "}}")
    (sp-local-pair sp--html-modes "{%" "%}")
    (sp-local-pair sp--html-modes "{#" "#}")

    :chords (("fd" . hydra-smartparens/body)))
#+END_SRC

** Region

#+BEGIN_SRC emacs-lisp
  (use-package wrap-region
    :straight t
    :config (wrap-region-global-mode t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :straight t
    :bind (("M-m" . er/expand-region)
           ("M-M" . er/contract-region))
    :config
    (with-eval-after-load 'latex-mode
      (require 'latex-mode-expansions)))
#+END_SRC

** Replacing

Gives you a visual preview at the point of replacement.

#+BEGIN_SRC emacs-lisp
  (use-package visual-regexp
    :straight t
    :bind (("C-c r" . vr/replace)
           ("C-c R" . vr/query-replace)))
#+END_SRC

** Navigation

Quickly move to every word and character on screen.

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :straight t
    :init
    (require 'hydra)
    (defhydra hydra-avy (:exit t :hint nil)
      "
   Line^^       Region^^        Goto
  ----------------------------------------------------------
   [_y_] yank   [_Y_] yank      [_c_] timed char  [_C_] char
   [_m_] move   [_M_] move      [_w_] word        [_W_] any word
   [_k_] kill   [_K_] kill      [_l_] line        [_L_] end of line"
      ("c" avy-goto-char-timer)
      ("C" avy-goto-char)
      ("w" avy-goto-word-1)
      ("W" avy-goto-word-0)
      ("l" avy-goto-line)
      ("L" avy-goto-end-of-line)
      ("m" avy-move-line)
      ("M" avy-move-region)
      ("k" avy-kill-whole-line)
      ("K" avy-kill-region)
      ("y" avy-copy-line)
      ("Y" avy-copy-region))
    :config
    (setq avy-timeout-seconds 0.25)

    :bind (("M-s" . avy-goto-char-timer)
           ("C-c a" . hydra-avy/body)))
#+END_SRC

Use smart beginning and end moves instead of just ~point-min~ and ~point-max~.

#+BEGIN_SRC emacs-lisp
  (use-package beginend
    :straight t
    :config
    (beginend-global-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package smartscan
    :straight t
    :hook (prog-mode . smartscan-mode)
    :custom
    ;; Look for symbols instead of words so that it works with UTF-8 identifiers
    (smartscan-symbol-selector "symbol"))
#+END_SRC

** Undo

Undoing can be quite tricky to keep track of mentally in emacs because the undo list also
records undos. `vundo` presents the undo list as a tree structure.

#+BEGIN_SRC emacs-lisp
  (use-package vundo
    :straight t
    :custom ((vundo-compact-display t))
    :bind (("C-c C-/" . vundo)))
#+END_SRC

* Code Intelligence

** Tree Sitter

#+BEGIN_SRC emacs-lisp
  (use-package tree-sitter :straight t)
  (use-package tree-sitter-langs :straight t)
#+END_SRC

** Language Server Protocol (LSP)

#+BEGIN_SRC emacs-lisp
  (use-package lsp-treemacs :straight t)
  (use-package lsp-headerline
    :custom ((lsp-headerline-breadcrumb-enable-diagnostics nil)))
  (use-package lsp-pylsp
    :custom ((lsp-pylsp-plugins-jedi-use-pyenv-environment t)
             (lsp-pylsp-plugins-jedi-completion-fuzzy t)))

  (use-package lsp-mode
    :straight t
    :custom ((lsp-auto-guess-root t)
             (lsp-auto-configure t)
             (lsp-signature-doc-lines 1)
             (lsp-keymap-prefix nil))
    :hook ((python-mode . lsp)
           (lsp-mode . lsp-enable-which-key-integration))
    :commands (lsp)
    :bind (("C-?" . lsp-describe-thing-at-point)
           ("<f10>" . lsp-rename)
           ("S-<f10>" . lsp-execute-code-action)
           :map lsp-mode-map
           ("C-S-SPC" . nil))
    :config
    (setq lsp-headerline-arrow
          (propertize ">" 'face 'lsp-headerline-breadcrumb-separator-face)))

  (use-package lsp-ui
    :straight t
    :custom ((lsp-ui-peek-show-directory nil)
             (lsp-ui-sideline-enable nil)
             (lsp-ui-doc-enable nil))
    :bind (("M-=" . lsp-ui-peek-find-references)
           :map lsp-ui-mode-map
                ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
                ([remap xref-find-references] . lsp-ui-peek-find-references)))
#+END_SRC

** Auto-Completion

#+BEGIN_SRC emacs-lisp
  (use-package company
    :straight t
    :bind ("C-M-SPC" . company-complete)
    :init
    (setf company-idle-delay 0
          company-minimum-prefix-length 2
          company-show-quick-access t
          company-selection-wrap-around t
          company-backends (list #'company-capf
                                 (list #'company-dabbrev-code
                                       #'company-keywords)
                                 #'company-files
                                 #'company-dabbrev)
          company-global-modes (list 'not 'org-mode))
    :config
    (global-company-mode t))

  (use-package company-dabbrev
    :straight company
    :init
    (setf company-dabbrev-ignore-case 'keep-prefix
          company-dabbrev-ignore-invisible t
          company-dabbrev-downcase nil))
#+END_SRC

** Complete from elsewhere

#+BEGIN_SRC emacs-lisp
  (use-package hippie-exp
    :bind ("M-/" . hippie-expand)
    :init
    (setf hippie-expand-try-functions-list
          '(try-expand-dabbrev-visible
            try-expand-dabbrev
            try-expand-dabbrev-all-buffers
            try-expand-line
            try-complete-lisp-symbol)))
#+END_SRC

** Snippets

#+BEGIN_SRC emacs-lisp
  (defun isnip-beginning-of-line-p ()
    "Is point at the beginning of a line semantically?"
    (save-excursion
      ;; Skip over the key of the triggering template
      (backward-word)
      (skip-chars-backward " \t")
      (or (= (point) (point-min)) (char-equal (char-before) ?\n))))

  (use-package yasnippet
    :straight t
    :demand t
    :bind (:map yas-minor-mode-map
                ("<tab>" . nil)
                ("TAB" . nil))
    :config
    (setq-default yas-buffer-local-condition yas-not-string-or-comment-condition)

    ;; Don't append newlines to snippet files
    (add-hook 'snippet-mode (lambda () (setq require-final-newline nil)))

    ;; `yas-maybe-expand' is not a function, so we cannot use :bind or bind-key and need to
    ;; load yasnippet eagerly
    (define-key yas-minor-mode-map (kbd "SPC") yas-maybe-expand)
    ;; Bind SPC globally because otherwise the fallthrough in `yas-maybe-expand` does not
    ;; work
    (define-key global-map (kbd "SPC") #'self-insert-command)

    ;; Circumvent snippet expansion with shift
    (define-key global-map (kbd "S-SPC") (lambda () (interactive) (insert " ")))

    (yas-global-mode t))
#+END_SRC

* Integrations

** git

#+BEGIN_SRC emacs-lisp
  ;; Stop asking me all the time when I visit a source file from a packge built with
  ;; straight.el (they symlink the .el files from the package repositories)
  (setq vc-follow-symlinks t)

  (use-package git-timemachine
    :straight (git-timemachine :host nil
                               :repo "https://codeberg.org/pidu/git-timemachine.git"))

  (use-package magit
    :straight t
    :after git-timemachine
    :bind (("<f2>" . magit-status)
           ("M-<f2>" . magit-list-repositories)
           ("<f5>" . magit-file-dispatch))
    :init
    (setq magit-last-seen-setup-instructions "1.4.0"
          magit-commit-ask-to-stage nil
          magit-push-always-verify nil
          magit-no-confirm '(set-and-push amend-published rebase-published)
          magit-repolist-columns
          '(("Name"    25 magit-repolist-column-ident ())
            ("Version" 25 magit-repolist-column-version ())
            ("D"        1 magit-repolist-column-dirty ())
            ("⇣"      3 magit-repolist-column-unpulled-from-upstream
             ((:right-align t)
              (:help-echo "Upstream changes not in branch")))
            ("⇡"        3 magit-repolist-column-unpushed-to-upstream
             ((:right-align t)
              (:help-echo "Local changes not in upstream")))
            ("Path"    99 magit-repolist-column-path ()))
          magit-repository-directories
          '(("~/.dotfiles" . 1) ("~/src" . 2)))

    :config
    (transient-append-suffix 'magit-file-dispatch "t" (list 1 "T" "Timemachine" #'git-timemachine)))
#+END_SRC

** dict.cc

#+BEGIN_SRC emacs-lisp
  (use-package dictcc
    :straight t
    :bind ("C-c d" . dictcc))
#+END_SRC

** Debugging

#+BEGIN_SRC emacs-lisp
  (use-package realgud
    :straight t
    :defer t)
#+END_SRC

* Writing

Put emacs into distraction-free writing mode on demand.

#+BEGIN_SRC emacs-lisp
  (use-package darkroom
    :straight (darkroom :repo "joaotavora/darkroom" :fetcher "github")
    :bind (("<f7>" . #'darkroom-mode))

    :config
    (setq darkroom-text-scale-increase 1.5))
#+END_SRC

** Linting

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :straight t
    :config
    (setq flycheck-textlint-config ".config/textlintrc.yml")
    (add-to-list 'flycheck-textlint-plugin-alist '(tex-mode . "latex2e"))
    (add-to-list 'flycheck-textlint-plugin-alist '(rst-mode . "rst"))

    (add-hook 'markdown-mode-hook #'flycheck-mode))
#+END_SRC

* Programming Languages

** Python

#+BEGIN_SRC emacs-lisp
  (use-package pyenv-mode :straight t)

  (defun ml-python-statement-at-point ()
    "Find the statement at point."
    (let* ((statement-types '(future_import_statement
                              import_statement
                              import_from_statement
                              print_statement
                              assert_statement
                              expression_statement
                              return_statement
                              delete_statement
                              raise_statement
                              pass_statement
                              break_statement
                              continue_statement
                              global_statement
                              nonlocal_statement
                              exec_statement))
           (this (tree-sitter-node-at-pos))
           result)
      (cl-loop until (or (not this) (seq-contains-p statement-types (tsc-node-type this)))
               do (setq this (tsc-get-parent this)))
      this))

  (defun ml-python-shell-send-statement ()
    "Send the statement surrounding point to inferior python process."
    (interactive)
    (when-let ((stmt (ml-python-statement-at-point)))
      (let ((code (buffer-substring-no-properties (tsc-node-start-position stmt)
                                                  (tsc-node-end-position stmt))))
        (python-shell-send-string code))))

  (defun cqql-python-shell-send-variable ()
    "Send the python expression at point."
    (interactive)
    (save-excursion
      (let (start end)
        (skip-chars-backward "[:alnum:].")
        (setq start (point))
        (skip-chars-forward "[:alnum:].")
        (setq end (point))
        (let ((var (buffer-substring start end)))
          (python-shell-send-string (format "print('%s'); print(%s)" var var))))))

  (require 'cl-lib)

  (defvar cqql-python-last-command nil
    "Stores the last sent region for resending.")

  (defun cqql-python-shell-send-region ()
    "Send the current region to inferior python process stripping indentation."
    (interactive)
    (let* ((start (save-excursion
                    (goto-char (region-beginning))
                    (beginning-of-line)
                    (point)))
           (end (save-excursion
                  (goto-char (region-end))
                  (end-of-line)
                  (point)))
           (region (buffer-substring start end))
           (command))
      ;; Strip indentation
      (with-temp-buffer
        (insert region)

        ;; Clear leading empty lines
        (goto-char (point-min))
        (while (char-equal (following-char) ?\n)
          (delete-char 1))

        ;; Remove indentation from all non-empty lines
        (let ((indent (save-excursion
                        (back-to-indentation)
                        (- (point) (point-min)))))
          (cl-loop until (eobp)
                   do
                   ;; Make sure that we do not delete empty lines or lines with
                   ;; only spaces but fewer than indent
                   (cl-loop repeat indent
                            while (char-equal (following-char) ?\s)
                            do (delete-char 1))
                   (forward-line 1)))
        (setq command (buffer-string)))
      (setq cqql-python-last-command command)
      (python-shell-send-string command)))

  (defun cqql-python-shell-resend-last-command ()
    "Resend the last command to the inferior python process."
    (interactive)
    (when cqql-python-last-command
      (python-shell-send-string cqql-python-last-command)))

  (defun cqql-python-shell-send-region-dwim ()
    "Send active region or resend last region."
    (interactive)
    (if (use-region-p)
        (cqql-python-shell-send-region)
      (cqql-python-shell-resend-last-command)))

  (defun cqql-python-reformat-buffer ()
    "Reformat the current buffer."
    (interactive)
    (isortify-buffer)
    (blacken-buffer))

  (defun cqql-imports-start ()
    "Find the start position for the imports in the current buffer."
    (save-excursion
      (goto-char 0)
      (if-let (import-end (re-search-forward "^[[:space:]]*\\(import\\|from\\)" nil t))
          (- (point) 6)
        (goto-char 0)
        (if (looking-at-p "#!")
            (progn
              ;; Skip shebang line and optionally one empty line
              (forward-line)
              (if (looking-at-p "\n") (forward-line))
              (beginning-of-line)
              (point))
          (point)))))

  (defun cqql-import-package (package &optional names)
    "Import PACKAGE, optionally importing just certain NAMES."
    (interactive
     (if current-prefix-arg
         (list (read-string "from ")
               (split-string (read-string "import ") "[[:space:]]*,[[:space:]]*"))
       (list (read-string "import "))))
    (let ((line (if names (format "from %s import %s" package (string-join names ", "))
                  (format "import %s" package))))
      (save-excursion
        (goto-char (cqql-imports-start))
        (insert line)
        (insert "\n"))))

  (use-package isortify
    :straight t
    :config
    (define-advice isortify-call-bin (:override (input-buffer output-buffer) call-bin)
      "Call the isort binary instead of the isort python module.

  This avoids having to install isort into a development
  environment and also a bad interaction where isort prints the
  reset_all CSI at the end of a file if colorama is available.
  "
      (with-current-buffer input-buffer
        (let ((process (make-process :name "isort"
                                     :command `("isort" ,@(isortify-call-args))
                                     :buffer output-buffer
                                     :noquery t
                                     :sentinel (lambda (process event)))))
          (process-send-region process (point-min) (point-max))
          (process-send-eof process)
          (process-send-eof process) ;; Close pipe twice on purpose to prevent deadlock.
          (accept-process-output process nil nil t)
          (while (process-live-p process)
            (accept-process-output process nil nil t))
          (process-exit-status process)))))

  (defun cqql-enable-local-pyenv ()
    (when-let ((buffer-path (buffer-file-name))
               (pyenv-dir (locate-dominating-file buffer-path ".python-version"))
               (mode (-> (f-join pyenv-dir ".python-version") f-read-text s-trim)))
      (pyenv-mode-set mode)))

  (defun ml-python-set-fill-column ()
    "Use fill-column 88 as is the default in black."
    (setq fill-column 88))

  (use-package python
    :bind (:map python-mode-map
                ("C-c D" . #'realgud:pdb)
                ("C-c f" . #'cqql-python-reformat-buffer)
                ("C-c C-l" . #'ml-python-shell-send-statement)
                ("C-c C-r" . #'cqql-python-shell-send-region-dwim)
                ("C-c C-v" . #'cqql-python-shell-send-variable)
                ("C-c t" . #'python-pytest-popup)
                ("C-c i" . #'cqql-import-package)
                ("C-c <left>" . #'python-indent-shift-left)
                ("C-c <right>" . #'python-indent-shift-right))

    :config
    (when (executable-find "ipython")
      (setq python-shell-interpreter "ipython"
            ;; Disable ipython 5 features that are incompatible with
            ;; inferior-python
            python-shell-interpreter-args "--simple-prompt")
      (push "ipython" python-shell-completion-native-disabled-interpreters))

    (setq python-fill-docstring-style 'pep-257-nn)

    (add-hook 'python-mode-hook #'eldoc-mode)
    (add-hook 'python-mode-hook #'subword-mode)
    (add-hook 'python-mode-hook #'pyenv-mode)
    (add-hook 'python-mode-hook #'python-docstring-mode)
    (add-hook 'python-mode-hook #'cqql-enable-local-pyenv)
    (add-hook 'python-mode-hook #'ml-python-set-fill-column)
    (add-hook 'python-mode-hook #'tree-sitter-hl-mode))

  (use-package python-pytest
    :straight t
    :bind (:map python-pytest-mode-map
                ("q" . #'bury-buffer)))

  (use-package python-docstring
    :straight t
    :config
    (setq python-docstring-sentence-end-double-space nil))

  (use-package blacken :straight t)

  (use-package pip-requirements :straight t)

  (use-package ein :straight t)
#+END_SRC

** Julia

#+BEGIN_SRC emacs-lisp
  (defun cqql-vterm-backward-kill-word ()
    "Kill previous word in vterm."
    (interactive)
    (vterm-send-key (kbd "C-w")))

  (use-package vterm
    :straight t
    :custom
    (vterm-max-scrollback 100000)
    :custom-face
    (vterm-color-black ((t . (:foreground "#2E3440" :background "#7B8394"))))
    (vterm-color-red ((t . (:foreground "#BF616A" :background "#D08770"))))
    (vterm-color-green ((t . (:foreground "#A3BE8C" :background "#434C5E"))))
    (vterm-color-yellow ((t . (:foreground "#EBCB8B" :background "#7B8394"))))
    (vterm-color-blue ((t . (:foreground "#81A1C1" :background "#D8DEE9"))))
    (vterm-color-magenta ((t . (:foreground "#5E81AC" :background "#B48EAD"))))
    (vterm-color-cyan ((t . (:foreground "#88C0D0" :background "#E5E9F0"))))
    (vterm-color-white ((t . (:foreground "#E5E9F0" :background "#ECEFF4"))))
    :bind (:map vterm-mode-map
                ("<C-backspace>" . cqql-vterm-backward-kill-word)
                ("M-i" . nil)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package julia-mode :straight t)

  (defun cqql-julia-repl-with-sysimage ()
    "Start a julia REPL with a sysimage in the project root."
    (interactive)
    (let* ((project-root (locate-dominating-file (buffer-file-name) "Project.toml"))
           (sysimage (if project-root (f-join project-root "sysimage.so")))
           (julia-repl-switches (when (and sysimage (f-exists-p sysimage))
                                  (concat "--sysimage " sysimage))))
      (julia-repl)))

  (use-package julia-repl
    :straight t
    :hook ((julia-mode . julia-repl-mode))
    :bind (:map julia-repl-mode-map
           ("C-c C-z" . cqql-julia-repl-with-sysimage))
    :config
    (julia-repl-set-terminal-backend 'vterm)

    (add-to-list 'julia-repl-captures (kbd "M-i")))
#+END_SRC

** Emacs Lisp

#+BEGIN_SRC emacs-lisp
  (defun cqql-run-all-ert-tests ()
    "Run all ert tests defined."
    (interactive)
    (ert t))

  (use-package macrostep :straight t)

  (use-package lisp-mode
    :config
    (bind-key "C-h C-f" 'find-function emacs-lisp-mode-map)
    (bind-key "C-c e t" 'cqql-run-all-ert-tests emacs-lisp-mode-map)
    (bind-key "C-c e b" 'eval-buffer emacs-lisp-mode-map)
    (bind-key "C-c e m" 'macrostep-expand emacs-lisp-mode-map)

    (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
    (add-hook 'emacs-lisp-mode-hook 'flycheck-mode)
    (add-hook 'emacs-lisp-mode-hook 'smartparens-strict-mode))
#+END_SRC

** Shell

#+BEGIN_SRC emacs-lisp
  (use-package sh-script
    :mode ("PKGBUILD\\'" . sh-mode)
    :config  (setq-default sh-basic-offset 2))
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
  (use-package racer :straight t)

  (use-package cargo :straight t)

  (use-package rust-mode
    :straight t
    :config
    (add-hook 'rust-mode-hook #'flycheck-mode)
    (add-hook 'rust-mode-hook #'racer-mode)
    (add-hook 'rust-mode-hook #'cargo-minor-mode))

  (use-package racer
    :straight t
    :config
    (add-hook 'racer-mode-hook #'eldoc-mode))

  (use-package  flycheck-rust :straight t)

  (use-package flycheck
    :straight t
    :after flycheck-rust
    :config
    (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
#+END_SRC

** COMMENT C/C++

#+BEGIN_SRC emacs-lisp
  (use-package cc-mode
    :mode ("\\.h\\'" . c++-mode)
    :config
    (require 'cqql)
    (bind-key "<C-return>" #'cqql-c-append-semicolon c-mode-base-map)
    (bind-key "C-c C-c" #'recompile c-mode-base-map)
    (bind-key "C-c C-o" #'ff-find-other-file c-mode-base-map)
    (bind-key "C-c f" #'clang-format-buffer c-mode-base-map)

    (add-hook 'c++-mode-hook #'subword-mode)
    (add-hook 'c++-mode-hook #'eglot-ensure))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package cquery
    :straight t
    :config
    (setq cquery-project-root-function #'projectile-project-root
          cquery-extra-init-params (list :index '(:comments 2)
                                         :cacheFormat "msgpack"
                                         :completion '(:detailedLabel t))))
#+END_SRC

*** Style Guide

#+BEGIN_SRC emacs-lisp
  (use-package google-c-style
    :straight t
    :demand t
    :config
    (add-hook 'c-mode-common-hook #'google-set-c-style))
#+END_SRC

*** Build Tools

#+BEGIN_SRC emacs-lisp
  (use-package cmake-mode :straight t)
#+END_SRC

** COMMENT javascript

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :straight t
    :mode (("\\.js\\'" . js2-mode) ("\\.jsx\\'" . js2-mode))
    :interpreter "node"
    :config
    (require 'js2-refactor)

    (setq-default js2-basic-offset 2)
    (setf js2-highlight-level 3
          js2-include-node-externs t)

    (js2r-add-keybindings-with-prefix "C-c r")

    (add-hook 'js2-mode-hook 'subword-mode))
#+END_SRC

* Text Formats

** LaTeX

LaTeX tables are really horrible to create and edit for most simple
use-cases. But ~org-mode~ comes to our rescue. Simply enabling ~org-table-mode~
gives you automatically resizing ASCII tables everywhere and you can even export
them to LaTeX!

#+BEGIN_SRC emacs-lisp
  (defun enable-word-wrap ()
    "Enable word wrapping."
    (interactive)
    ;; Disable line wrap fringe indicators
    (make-variable-buffer-local 'fringe-indicator-alist)
    (setf (alist-get 'continuation fringe-indicator-alist) nil)
    (setq word-wrap t))

  (defun cqql-latex-append-line-break ()
    "Insert the \\\\ macro at the end of the line."
    (interactive)
    (save-excursion
      (move-end-of-line nil)
      (insert "\\\\")))

  (use-package tex
    :straight auctex
    :mode ("\\.tex\\'" . LaTeX-mode)
    :custom ((TeX-auto-save t)
             (TeX-parse-self t)
             (TeX-save-query nil)
             (prettify-symbols-unprettify-at-point 'right-edge))
    :hook ((LaTeX-mode . TeX-source-correlate-mode)
           (LaTeX-mode . TeX-PDF-mode)
           (LaTeX-mode . prettify-symbols-mode)
           (LaTeX-mode . reftex-mode)
           (LaTeX-mode . flycheck-mode)
           (LaTeX-mode . orgtbl-mode)
           (LaTeX-mode . enable-word-wrap))
    :bind (:map TeX-mode-map
                ("<C-return>" . #'cqql-latex-append-line-break))
    :config
    ;; Workaround for smartparens overwriting `
    (require 'smartparens-latex))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defvar cqql-preview-scale 1.35)

  (defun cqql-preview-scale-up ()
    "Scale up previews."
    (* cqql-preview-scale (funcall (preview-scale-from-face))))

  (use-package reftex
    :custom ((reftex-toc-follow-mode t)
             (reftex-cite-format 'natbib)))

  (use-package preview
    :after tex
    :custom ((preview-scale-function #'cqql-preview-scale-up)
             (preview-auto-cache-preamble t))
    :pretty-hydra
    ((:quit-key "g" :title "preview" :color blue)
     ("preview"
      (("p" preview-at-point "at point")
       ("d" preview-document "document")
       ("b" preview-buffer "buffer")
       ("s" preview-section "section")
       ("r" preview-region "region")
       ("e" preview-environment "environment"))
      "clear"
      (("P" preview-clearout-at-point "at point")
       ("D" preview-clearout-document "document")
       ("B" preview-clearout-buffer "buffer")
       ("S" preview-clearout-section "section")
       ("R" preview-clearout "region"))
      "cache"
      (("c" preview-cache-preamble "refresh preamble"))))
    :bind (:map LaTeX-mode-map ("C-c p" . preview-hydra/body)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package cdlatex
    :straight t
    :after latex
    :hook (LaTeX-mode . cdlatex-mode)
    :custom ((cdlatex-make-sub-superscript-roman-if-pressed-twice t)
             (cdlatex-auto-help-delay 0.5))
    :bind (:map cdlatex-mode-map
                ("(" . nil)
                ("<" . nil)
                ("[" . nil)
                ("{" . nil)
                ("|" . nil)))
#+END_SRC

** org

#+BEGIN_SRC emacs-lisp
  (defun cqql-open-notes-file ()
    "Open the default org file."
    (interactive)
    (find-file (concat org-directory
                       "/"
                       org-default-notes-file)))

  (use-package org
    :straight t
    :init
    (setf org-directory "~/notes"
          org-agenda-files (list org-directory)
          org-default-notes-file "notes.org"
          org-crypt-key nil
          org-tags-exclude-from-inheritance (list "crypt")
          org-startup-indented t
          org-M-RET-may-split-line nil
          org-enforce-todo-dependencies t
          org-enforce-todo-checkbox-dependencies t
          org-agenda-start-on-weekday nil)

    :config
    (require 'org-crypt)
    (org-crypt-use-before-save-magic)

    ;; Configure org-babel
    (setf org-src-fontify-natively t
          org-babel-load-languages '((emacs-lisp . t)
                                     (python . t)
                                     (shell . t)))

    ;; Load language support
    (org-babel-do-load-languages
     'org-babel-load-languages
     org-babel-load-languages)

    (add-hook 'org-mode-hook #'flycheck-mode))
#+END_SRC

Use some nice UTF-8 symbols to signify the nesting depth.

#+BEGIN_SRC emacs-lisp
  (use-package org-superstar
    :straight t
    :custom ((org-superstar-headline-bullets-list '("◉" "◈" "○" "▷"))
             (org-superstar-cycle-headline-bullets nil))
    :config
    (add-hook 'org-mode-hook 'org-superstar-mode))
#+END_SRC

** markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :straight t)
#+END_SRC

** reStructuredText

#+BEGIN_SRC emacs-lisp
  (defun cqql-length-of-line ()
    "Return length of the current line."
    (save-excursion
      (- (progn (end-of-line) (point))
         (progn (beginning-of-line) (point)))))

  (defun cqql-underline ()
    "Repeat the character at point until it stretches the length of
    the previous line."
    (interactive)
    (let* ((char (preceding-char))
           (prev-length (save-excursion
                          (forward-line -1)
                          (cqql-length-of-line)))
           (curr-length (save-excursion
                          (cqql-length-of-line)))
           (repeat-length (max 0 (- prev-length curr-length))))
      (insert (s-repeat repeat-length (char-to-string char)))))

  (use-package rst
    :straight t
    :config
    (bind-key "<C-right>" #'cqql-underline rst-mode-map)

    (add-hook 'rst-mode-hook #'flycheck-mode))
#+END_SRC

** YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode :straight t)
#+END_SRC

** HTML/jinja2

#+BEGIN_SRC emacs-lisp
    (use-package web-mode
      :straight t
      :mode "\\.html\\.?"
      :config
      ;; Disable inserting closing parens etc. because we have smartparens already
      (setq web-mode-enable-auto-pairing nil))
#+END_SRC

* Package Footer

#+BEGIN_SRC emacs-lisp

  (provide 'ml-init)
  ;;; ml-init.el ends here
#+END_SRC
